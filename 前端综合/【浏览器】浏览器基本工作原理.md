## 1.浏览器内部组成

我们先来看浏览器的内部组成（以 chrome 为例）：
![](https://img-blog.csdnimg.cn/img_convert/75dadb1f64c6ce2dc5a14ce94994436c.png)
我们看到浏览器主要包括：

- 1 个浏览器主进程
  主要负责界面显示，用户交互，子进程管理

- 多个渲染进程
  一般浏览器会为每个 Tab 标签窗口创建一个渲染进程，主要负责将 html，css，JavaScript 转换成我们看到的网页，里面包含多个线程，比如 JavaScript 的 V8 引擎。

- 1 个 GPU 进程
  主要负责复杂的计算，比如 3D 动画，图形绘制。

- 1 个网络进程
  主要负责网络资源加载

- 多个插件进程
  浏览器器每个插件都会分配一个插件进程。

## 2.从一个 url 开始

我们下面来看在地址栏输入一个 url 后，浏览器做了什么事，我们先来看下流程图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210430154007565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAwMTM0MDU=,size_16,color_FFFFFF,t_70)
下面我们来分析下上面的流程图：

- 当用户在地址栏输入一个地址或者关键字，并按下回车键的时候，意味着当前页面很快要被替换，在这个时候会触发当前页面的 beforeunload 事件。
  然后浏览器的当前 tab 栏就变成加载状态，变成一个转动的圆圈，此时页面还没有开始改变，需要等到后面“提交文档”后，才会别新内容替换。
- 浏览器主进程合成完整 Url：如果是输入的是地址，比如 "baidu.com"，则自动合成为：https://www.baidu.com/。
  如果输入的是关键字，则使用默认搜索引擎，合成带搜索关键字 Url，比如输入：'hello'，默认搜索引擎为百度，则合成为：https://www.baidu.com/s?ie=UTF-8&wd=hello
  然后把完整 url 发送给网络进程。
- 网络进程接收到 url 请求后，先判断是否本地缓存了资源。如果有，则直接返回资源给浏览器主进程，不发起网络请求。如果没有缓存，则进入网络请求。
- 网络请求之前，先要进行 DNS 解析，把域名转换成 ip，这一步也是先查 DNS 缓存，如果有当前域名的缓存，则从缓存中直接取对应 ip。
  如果没有缓存，则从 DMS 服务器请求 ip。然后构建请求体，请求头（包括 cookie）等信息，向服务端发送网络请求（建立 Tcp 链接）。
- 服务端接收到请求消息后，进行对应操作，然后生成响应数据，发送给网络进程。
- 网络进程接收到服务器返回的响应数据后，先解析响应头信息，判断状态码是否为重定向（3xx),如果是，则取响应头中 Location 字段，重新发起请求。
  如状态码为 200，表示请求成功，可以继续处理请求。
- 如果状态码为 200，浏览器主进程会根据响应头中的 Content-Type 字段做出响应对策，如果此字段的值为 application/octet-stream，则启动下载流程。
  如果 Content-Type 为 text/html，则启动渲染流程。
- 默认情况下，浏览器会为每一个 tab 页签创建一个渲染进程，但是如果是同一个站点（根域名+协议相同，端口+子域名不同），则共用一个渲染进程。
- 进入渲染流程开始前，浏览器主进程会发送一个“接收文档”消息给渲染进程，这里的文档是指存在网络进程里面的响应体信息。
- 渲染进程接收到“提交文档”的消息后，会和网络进程建立一个通道，接收数据。
- 渲染进程接收到数据后，开始向浏览器主进程发送“确认提交”,消息
- 浏览器主进程接收到“确认提交”的消息后，开始更新浏览器页面，包括：地址栏的 url，前进后退按钮。
- 渲染进程开始生成页面，这个过程是一边接收一边生成。当页面渲染完毕后（当前页面及内部 iframe 都出发了 onload 事件），发送“渲染完毕”消息。
- 浏览器主进程接收到消息后，显示页面，并停止标签栏的加载动画。

到这里为止，当我们在地址栏输入一个 url，然后到页面展示在我们面前的大致流程就梳理完毕了。但是这里面还有一个非常重要的环节，就是`页面解析`的流程我们上面只是一带而过，这是渲染进程来做的工作，下面来具体展开。

## 3.渲染进程

渲染进程的核心工作就是解析接收到的 html/js/css 代码，并将其转换成用户可交互的页面。
渲染进成包含：

- 主线程 GUI：负责解析 dom 结构
- js 引擎线程：负责执行 js 代码，会阻塞主进程。
- 合成线程：分组，合成，并把视口附近图块提交给光栅化线程。
- 多个光栅化线程：生成位图，即页面需要的每个像素点的颜色值（我们看到的页面其实就是每个像素点的颜色）
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210430222452306.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAwMTM0MDU=,size_16,color_FFFFFF,t_70)
  下面来分析以下流程图：
- 渲染进程开始接受到数据的时候，为了提高效率，会先预扫描接收到的数据，如果如果发现有需要加载资源的标签（img,link,外部 script 等），就先告诉浏览器主进程，先去下载，这个过程叫`预解析`,这个任务交出去后，就继续做自己本职工作,解析 html 文件。 -当主线程`解析html`文件时，会碰到三种类型数据：html 标签，css 代码，js 代码。
  - html 标签：对于普通的 html 标签，会`生成Dom树`(标签节点的结构树，是浏览器的内置对象，会有一些内置方法和属性)。
  - css 样式：对于 css 代码，会根据 css 的样式选择器`构建cssDom树`,并对样式进行计算(rem，em 转换为 px，没有定义样式的提供默认样式），生成`computedStyle`。
    如果遇到的是 css 外部链接，如果从预解析开始还没下载完，则继续下载，不会阻塞解析。
  - js 代码：对于 js 代码，会先判断 js 代码前的 css 有没有解析完（包括外部 css 的下载），如果没有则等待 css 代码下载完并解析完毕，然后再执行 js 代码。js 执行期间`阻塞解析`。所以步骤是这样：
    **遇到 js -> 阻塞 dom 树构建 -> css 下载 -> css 解析->js 执行->继续构建 dom 树**
  - js 链接：对于 js 的链接，如果标签上没有设置异步标志（async/defer),则和普通的 js 代码一样，下载也会阻塞 dom 解析，也需要等 css 下载解析完，但是 css 下载不会阻塞 js 下载，步骤如下：
    **遇到 js 链接(无异步标签) -> 阻塞 dom 树构建 -> css 下载（同时 js 下载） -> css 解析->js 执行->继续构建 dom 树**
    如果有异步标签，则下载不阻塞 dom 树构建，async 文件下载完，立即执行。defer 文件下载完，等 html 解析完，按加载顺序执行。步骤如下：
    **遇到 js 链接(async) ->下载 js（不影响 dom 构建） -> js 下载完毕 -> 立即执行 js（走普通 js 代码流程）**
    **遇到 js 链接(defer) ->下载 js（不影响 dom 构建） -> js 下载完毕 -> 等 html 解析完毕 -> 按顺序执行 js**
- 等 dom 树和 computedStyle 都构建完毕后(要都构建完毕), 更具 dom 树和 computedStyle，`构建布局树layoutTree`,布局树包含每个节点的`位置坐标`和盒模型的`大小`，并且剔除了`隐藏`的节点（样式设置了 display:none 的节点)。
- 等布局树 layoutTree 构建完毕后，我们已经知道了页面上要显示的每个节点的大小，位置和样式。继续来主线程会对节点进行分层，通过遍历 layoutTree`构建图层树layerTree`。哪些节点会被分为一层呢？分为两种情况：
  - 拥有层叠上下文属性的元素会被单独提升为一层([什么是层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)),包含设置了 z-index，transform，will-change，filter，opacity<1,flex 子元素等等。
  - 需要裁剪的地方会被分为一层，即元素的大小被限制，而内容超出元素大小，内容被裁剪。
- 图层树 layerTree 被创建后，会为每一个图层`创建绘制指令`列表，可以再浏览器调试窗口的 layers 标签下查看分层和指令列表信息。渲染进程的主线程把绘制指令生成后，并不执行，而是转交给合成线程。
- 合成线程先把`图层分为图块`(大小通常为 256*256/512*512)，然后把浏览器用户`视口附近`的图块优先交给栅格化线程来生成位图。
- 栅格化的最小执行单位是图块，即最少要把一个图块`栅格化`。栅格化的过程通常会用 GPU 执行，就是说栅格化线程会把绘制图块的指令发送给 GPU，然后 GPU 生成图块的位图（像素点的颜色值），存在 GPU 内存。
- 当视口附近所有图块栅格化完毕后，合成线程发送 DrawQuad 指令给浏览器主进程，浏览器主进程把页面的内容显示在屏幕上。

### 4.应用

那么知道了浏览器的基本原理后，对我们开发有什么实际的作用呢？以下总结了几点：

- css 会阻塞 js，js 会阻塞 dom 解析，所以尽量把 css 文件放页面上面，js 放在页面下面。
- 对于不会影响页面内容的 js 外部文件，可以用 async/defer 标记来异步加载。
- css 动画效率比 js 操作 dom 实现动画好，因为 css 动画的只会引起`合成`及以后步骤的重新执行。而合成步骤是在`合成线程`,不会阻塞渲染的主线程。而 js 如果影响到 dom 节点的大小样式位置，则需要触发`布局`及以后的步骤。

**参考：**

- [前端都该懂的浏览器工作原理，你懂了吗？](https://mp.weixin.qq.com/s/uMuiX_8j_EJGUfDPwWf9Eg)
- [浏览器工作原理与实践](https://time.geekbang.org/column/intro/100033601)
